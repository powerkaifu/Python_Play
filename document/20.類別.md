# Python

Python 每個變數都是一個件，物件都有著他對應的類別。
由於是動態式物件導向程式設計語言，所以類別不需要宣告變數的型別，也不需要在類別中宣告變數。

例如:

```py
a = 10 # 對應的類別是 int
b = "Hello" # 對應的類別是 str
c = 3.14 # 對應的類別是 float
d = True # 對應的類別是 bool
e = None # 對應的類別是 NoneType
f = [1, 2, 3] # 對應的類別是 list
g = (1, 2, 3) # 對應的類別是 tuple
h = {1, 2, 3} # 對應的類別是 set
i = {"name": "John", "age": 30} # 對應的類別是 dict
```

# class、檔案、目錄命名

- class 採用大駝峰命名法，例如 `QuestionAdmin`
- 檔案通常小寫，使用底線 `_` 連接，例如 `my_class.py`
- 目錄通常小寫即可，例如 `models`、`views`。

# self

Python 的 self 與 Java 的 this 一樣，是指向物件(實例)本身的指標。
self 只是一個命名慣例，你可以使用任何名稱，但建議使用 self，

- 建構子第一個參數必須是 self。
- self.name 是指物件的屬性。
- department 是指類別的屬性。

```py
class Circle:
  number = 0 # 類別屬性

  def __init__(self, r = 1):
    self.radius = r # 物件屬性
    Circle.number += 1 # 透過類別名稱.類別屬性，取得類別屬性的值

  def area(self):
    return 3.14 * self.radius**2


c1 = Circle(10)
print(c1.number)  # 透過物件.類別屬性，取得類別屬性的值，不建議

c2 = Circle(5)
print(c2.number)  # 透過物件.類別屬性，取得類別屬性的值，不建議

print(Circle.number)  # 透過類別名稱.類別屬性，取得類別屬性的值
"""
結論:
雖然可以透過物件.類別屬性，取得類別屬性的值，但不建議這樣做
類別屬性建議透過類別名稱.類別屬性來取得
"""

# 透過類別方法，並將物件傳入，取得面積，此時 c1、c2 指的是方法中的 self
Circle.area(c1)  # 314.0
Circle.area(c2)  # 78.5
```

# `__class__` 取得物件的類別

```
Circle.number 可以用 __class__.number 代替
```

# `__init__()` 初始化

- 如同 Java 的建構子，Python 也有建構子，名稱為 `__init__()`。
- `__init__()` 方法是在物件被建立時自動呼叫的。
- 可以省略建構子，Python 會提供預設建構子。

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def say_hello(self):
        print(f'Hello, my name is {self.name}, I am {self.age} years old.')
```

# 方法

若想對物件的屬性進行操作，可以定義方法。
方法命名採用小寫字母，若有多個單字，使用底線 `_` 連接。

```py
import math
class Circle:
    def __init__(self, radius):
        self.radius = radius

    def get_area(self):
        return math.pi * self.radius ** 2
```

# 沒有 new，直接用類作為函數來創建實例物件

```python
John = Person("John", 30)
```

# 查詢屬性的方法

| 方法                    | 說明                               |
| ----------------------- | ---------------------------------- |
| isinstance(obj, cls)    | 查詢 obj 物件是否為 cls 類別的實例 |
| getattr(obj, 'grade')   | 取得 obj 物件的 attr 屬性值        |
| setattr(obj, attr, val) | 設定 obj 物件的 attr 屬性值為 val  |
| hasattr(obj, attr)      | 查詢 obj 物件是否有 attr 屬性      |

```py
isinstance(5, int) # True
getattr(John, 'name') # 'John'
setattr(John, 'name', 'Mary')
hasattr(John, 'name') # True
```

# `__repr__()`、`__str__()`、`__eq__()`

這三個方法是 Python 物件的特殊方法，可以自定義物件的行為。
str 方法優先權高於 repr 方法，所以 print() 會呼叫 str 方法。
但可以使用 repr() 來呼叫 repr 方法。
而 eq 方法式用來判斷兩個物件是否相等，回傳 True 或 False。

- `__repr__()`：查詢物件時，會回傳物件的屬性值，repr 是 represtation，是代表、表示的意思。
- `__str__()`：回傳物件的字串表示。
- `__eq__()`：判斷兩個物件是否相等。

```py
class Student:

  def __init__(self, name, age, grade):
    self.name = name
    self.age = age
    self.grade = grade

  def showInfo(self):
    print(f'{self.name} 的年紀是 {self.age}，他的分數是 {self.grade}')

  def __repr__(self):
    return f'Student(name={self.name}, age={self.age})' # 回傳物件的屬性值

  def __str__(self):
    return self.name

  def __eq__(self, other):
    if self.grade == other.grade:
      return True
    else:
      return False


KaiFu = Student('KaiFu', 18, 100)
Mary = Student('Mary', 28, 100)

print(repr(KaiFu))  # 可以用 repr() 呼叫 __repr__ 方法
print(KaiFu)  # 呼叫 __str__ 方法
print(KaiFu == Mary)  # 呼叫 __eq__ 方法
```

# @classmethod 與 @staticmethod

透過裝飾器來定義類別方法與靜態方法。

## @classmethod(類別方法)

類方法是針對類別的方法，第一個參數是 cls，可以存取類別屬性。(可以修改)
如果要修改類別屬性，建議使用 @classmethod 裝飾器。

- 第一個參數是 cls，可以存取類別屬性。

## @staticmethod(靜態方法)

靜態方法是一個獨立的方法，不需要存取類別屬性。(不能修改)
當不需要修改類別屬性時，可以使用 @staticmethod 裝飾器。

- 不需要第一個參數 cls。

```py
class Student:
  total_people = 30
  department = '軟創學程'

  def __init__(self, name, age, grade):
    self.name = name
    self.age = age
    self.grade = grade

  @classmethod
  def set_total_people(cls):  # cls 代表 class
    cls.total_people += 1

  @classmethod
  def get_total_people(cls):
    print(cls.total_people)
  @classmethod
  def set_total_people(cls):
    cls.total_people += 1

  @staticmethod
  def get_department():
    print(Student.department)

# 類別方法可以透過類別名稱呼叫，並且可以修改類別屬性
Student.set_total_people()  # total_people += 1
Student.get_total_people()  # 31

# 靜態方法可以透過類別名稱呼叫
Student.get_department()  # 軟創學程
```

# @property 定義私有屬性的 getter/setter

@property 裝飾器可以將方法變成屬性，讓使用者可以直接存取私有屬性。
也就是說 @property 通常用於定義私有屬性的 getter/setter。

結論：

- 使用私有屬性搭配 @property 裝飾器來定義 getter/setter。
- 若沒有定義 @property，直接對 name 修改，會創建一個新的 name 屬性。
  - 可以用 **dict** 來檢查物件的屬性列表。

```py
class Person:

  def __init__(self, name, age, department):
    self.__name = name # 私有屬性
    self.__age = age # 私有屬性
    self.department = '' # 公開屬性

  @property # getter
  def name(self):
    return self.__name

  @name.setter # setter
  def name(self, name):
    self.__name = name


KaiFu = Person('KaiFu', 18, '軟創')
KaiFu.name = 'KaiFu2' # 透過 @property 可以直接修改私有屬性
KaiFu.department = '軟創學程' # 因為是公開屬性，所以可以直接修改

# 檢查 KaiFu 物件的 __dict__
# {'_Person__name': 'KaiFu2', '_Person__age': 18, 'department': '軟創學程'}
print(KaiFu.__dict__)
```

# 繼承

```py
# 父類別
class Radius:

  def __init__(self, r):
    self.rad = r

  def show(self):
    print('rad=', self.rad)

# 子類別
from radius import Radius

class Circle(Radius):  # 繼承父類別 Radius

  def __init__(self, c, r = 1):
    super().__init__(r)  # 呼叫父類別的建構函式，就可以設定 rad
    self.color = c

  # override 覆寫父類別的方法
  def show(self):
    print('color=', self.color, 'rad=', self.rad)
    super().show()  # 呼叫父類別的方法

  def area(self):
    super().show()  # 呼叫父類別的方法
    return 3.14 * self.rad**2

  def display(self):
    print('呼叫父類別的方法')
    super().show()  # 呼叫父類別的方法
    print('呼叫自己的方法')
    self.show()  # 呼叫自己的方法

# main
from circle import Circle

c1 = Circle('blue', 10)
print(c1.rad)
print(c1.color)

c1.show()
area1 = c1.area()
print(area1)

print('-' * 30)
c1.display()

```
