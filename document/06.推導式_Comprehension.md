# 當沒有推導式時...

```py
# 沒有使用 list comprehension
squares = []
for x in range(10):
  squares.append(x**2)

print(squares)

# 使用 list comprehension
squares = [x**2 for x in range(10)]
print(squares)

# 使用 map() 和 lambda
squares = list(map(lambda x: x**2, range(10)))
print(squares)

```

# 推導式

推導式（Comprehension）是一種簡潔的語法，
用於從**可迭代對象**中推導新的數據結構（如列表、集合、字典或推導器）。
推導式可以使代碼更加簡潔和易讀，
通常比**傳統的循環和條件語句**更高效。

雖然推導式可以用於列表、集合、字典和推導器，
但最常見的用法是列表推導式（List Comprehension）。

## 基本型列表推導式（Basic List Comprehension）

從可迭代對象中取出每個元素，對每個元素應用表達式，並將結果收集起來。

```py
[表達式 for 元素 in 可迭代對象]
```

```py
# 推導一個新的列表，其中每個元素是原來元素的兩倍
numbers = [x * 2 for x in range(1, 6)]
# 結果: [2, 4, 6, 8, 10]
```

## 篩選型列表推導式（Filtering List Comprehension）

**篩選型推導式是用來過濾元素的好方法！**

從一個可迭代的對象中取出每個元素，根據條件篩選(filter)後，
對符合條件的元素應用表達式，並將結果收集起來。

```py
[表達式 for 元素 in 可迭代對象 if 條件]
```

## 條件表達式型列表推導式（Conditional Expression List Comprehension）

從可迭代對象中的每個元素，
如果條件成立，則推導[條件為真時的表達式]；
否則，推導[條件為假時的表達式]

```py
[條件為真時的表達式 if 條件 else 條件為假時的表達式 for 元素 in 可迭代對象]
```

```python
["even" if x % 2 == 0 else "odd" for x in range(1, 11)]
# 結果: ['odd', 'even', 'odd', 'even', 'odd', 'even', 'odd', 'even', 'odd', 'even']
```

# 多個 for 迴圈

```py
[(x, y) for x in range(1, 4) for y in range(1, 4) if x != y]
# 結果: [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)]
```

相當於：

```py
result = []
for x in range(1, 4):
  for y in range(1, 4):
    if x != y:
      result.append((x, y))
```

# 巢狀列表推導式

```py
# _ 是一個慣例，表示我們不會使用這個變數
matrix = [[x for x in range(1, 4)] for _ in range(3)]
# 結果: [[1, 2, 3], [1, 2, 3], [1, 2, 3]]
```

# 轉換資料結構

推導式通常推導與其操作的數據結構相同的類型，但也可以根據需求進行轉換。

```py
numbers_set = set([x * 2 for x in range(1, 6)])
# 結果: {2, 4, 6, 8, 10}
```

# del 刪除列表元素

```py
numbers = [1, 2, 3, 4, 5]

# 刪除指定索引元素
del numbers[1]
# 結果: [1, 3, 4, 5]

# 完全刪除整個列表，刪除記憶體
del numbers

# 刪除所有元素，會變成空列表，等同於 numbers.clear()
del numbers[:]

# 或刪除範圍元素
del numbers[1:3] # 刪除第 1 到 3 之間的元素
```
